#include <cuda_runtime.h> 
#include "cublas_v2.h"
#include <device_launch_parameters.h>
#include<stdio.h>
#include <time.h>  
#include <iostream>  
#include <array>
#include "gdal_priv.h"
#include "ogr_spatialref.h"
#include<ctime>
#include<math.h>
#include <algorithm>
#include"NDVI.h"
#include <omp.h>
#include <stdio.h>



#define BLOCK_NUM 32   //块数量
#define THREAD_NUM 256 // 每个块中的线程数
#define R_SIZE BLOCK_NUM * THREAD_NUM
#define M_SIZE R_SIZE * R_SIZE
#define THREADS_PER_BLOCK 1024
#define D 6 //时序 
#define K 4  //分类的数量
#define X 4000//宽度
#define Y 4000//高度

using namespace std;

#define CHECK(call)							\
{											\
const cudaError_t error = call;				\
	if (error != cudaSuccess)				\
	{										\
printf("error:%s:%d", __FILE__, __LINE__);	\
printf("code:%d,reason:%s\n",error,cudaGetErrorString(error));	\
exit(-10*error);				\
}	\
}\


void getInfo(int idev, cudaDeviceProp iprop)
{
	cudaGetDeviceProperties(&iprop, idev);
	printf("device %d:%s\n", idev, iprop.name);
	printf("const memoru: %1.2f KB\n", iprop.totalConstMem);
	printf("registers of available per block:%d\n", iprop.regsPerBlock);
	printf("Warp size%d\n", iprop.warpSize);
	printf("每个线程块最大线程数量:%d\n", iprop.maxThreadsPerBlock);
	printf("每个SM最大线程数量:%d\n", iprop.maxThreadsPerMultiProcessor);
	printf("每个SM最大线程束数量：%d\n", iprop.maxThreadsPerMultiProcessor / 32);
}

void checkresult(const char* CPUFileName, const char* GPUFileName)
{
	int count = 0;
	GDALDataset* CPUDataset;
	GDALDataset* GPUDataset;
	GDALAllRegister();
	cout << "正在进行结果验证。。。" << endl;
	CPUDataset = (GDALDataset *)GDALOpen(CPUFileName, GA_ReadOnly);
	GPUDataset = (GDALDataset *)GDALOpen(GPUFileName, GA_ReadOnly);

	int imgSizeX = CPUDataset->GetRasterXSize(); // 影像的宽度（像元数目）
	int imgSizeY = GPUDataset->GetRasterYSize(); // 影像的高度（像元数目）


	const char* imageFormat = "GTiff";
	GDALDriver* gdalDriver = GetGDALDriverManager()->GetDriverByName(imageFormat);

	GDALRasterBand* raseterBandCPU = CPUDataset->GetRasterBand(1);
	GDALRasterBand* raseterBandGPU = GPUDataset->GetRasterBand(1);

	float* bufferCPU = (float*)CPLMalloc(sizeof(float) * imgSizeX);
	float* bufferGPU = (float*)CPLMalloc(sizeof(float) * imgSizeX);



	for (int i = 0; i < imgSizeY; i++)
	{

		raseterBandCPU->RasterIO(GF_Read, 0, i, imgSizeX, 1, bufferCPU, imgSizeX, 1, GDT_UInt32, 0, 0);
		raseterBandGPU->RasterIO(GF_Read, 0, i, imgSizeX, 1, bufferGPU, imgSizeX, 1, GDT_UInt32, 0, 0);

		for (int j = 0; j < imgSizeX; j++)
		{
			if (bufferCPU[j] = bufferGPU[j])
			{
				count++;
			}

		}
	}

	CPLFree(bufferCPU);
	CPLFree(bufferGPU);

	GDALClose(CPUDataset);
	GDALClose(GPUDataset);
	double p;
	p = count / (imgSizeX*imgSizeY);
	cout << "gpu分类的精度为：" << p << endl;
}




__constant__ float wheat[D] = { -0.12, -0.06, 0.08, 0.45, 0.42, 0.4 };			//outbuffer->1
__constant__ float reed[D] = { 0.11,0.25,0.52,0.46,0.13,0.04 };		//outbuffer->2
__constant__ float tomato[D] = { -0.14,-0.07,-0.03,0.44,0.51,0.16 };		//outbuffer->3	
__constant__ float beet[D] = { -0.08,0.06,0.32,0.35,0.47,0.5 };		//outbuffer->4


__constant__  int day[D] = { 0,30,60,90,120,150 };					//每两幅图像之间的时间间隔




__global__ void ndviOnGPU(float*Ar, float *An, float *Br, float *Bn, float*Cr, float *Cn, float*Dr,
	float *Dn, float*Er, float *En, float*Fr, float *Fn,  float *C, const int N, const int nx, const int ny)
{

	float nd[D];									//时序NDVI数组 
	unsigned int i = blockIdx.x * blockDim.x + threadIdx.x;

	if (Ar[i] != 0 && An[i] != 0 && Br[i] != 0 && Bn[i] != 0 && Cr[i] != 0 && Cn[i] != 0 && Dr[i] != 0 &&
		Dn[i] != 0 && Er[i] != 0 && En[i] != 0 && Fr[i] != 0 && Fn[i] != 0 ) {

		nd[0] = (An[i] - Ar[i]) / (Ar[i] + An[i]);
		nd[1] = (Bn[i] - Br[i]) / (Br[i] + Bn[i]);
		nd[2] = (Cn[i] - Cr[i]) / (Cr[i] + Cn[i]);
		nd[3] = (Dn[i] - Dr[i]) / (Dr[i] + Dn[i]);
		nd[4] = (En[i] - Er[i]) / (Er[i] + En[i]);
		nd[5] = (Fn[i] - Fr[i]) / (Fr[i] + Fn[i]);



		//计算累积成本矩阵
		float b[K];	//最终累积距离的比较 K类
		float q[D][D];	//累积距离	D天
		float s[D][D];	//矩阵	

		//计算beat
		for (int m = 0;m < D;m++)
		{
			for (int n = 0;n < D;n++)
			{
				s[m][n] = abs(beet[m] - nd[n]) + (1 + (exp(-0.1*(abs(day[m] - day[n]) - 105))));

				if (m == 0 && n == 0)
				{
					q[m][n] = s[0][0];
					continue;
				}
				if (m == 0 && n > 0)
				{
					q[m][n] = s[m][n] + q[0][n - 1];
					continue;
				}

				if (m > 0 && n == 0)
				{
					q[m][n] = s[m][n] + q[m - 1][0];
					continue;
				}
				else
				{
					q[m][n] = min(q[m - 1][n - 1], min(q[m][n - 1], q[m - 1][n])) + s[m][n];
				}

			}

		}
		C[i * K] = q[D - 1][D - 1];
		//计算reed
		for (int m = 0;m < D;m++)
		{
			for (int n = 0;n < D;n++)
			{
				s[m][n] = abs(reed[m] - nd[n]) + (1 + (exp(-0.1*(abs(day[m] - day[n]) - 105))));

				if (m == 0 && n == 0)
				{
					q[m][n] = s[0][0];
					continue;
				}
				if (m == 0 && n > 0)
				{
					q[m][n] = s[m][n] + q[0][n - 1];
					continue;
				}

				if (m > 0 && n == 0)
				{
					q[m][n] = s[m][n] + q[m - 1][0];
					continue;
				}
				else
				{
					q[m][n] = min(q[m - 1][n - 1], min(q[m][n - 1], q[m - 1][n])) + s[m][n];
				}

			}

		}
		C[i * K + 1] = q[D - 1][D - 1];
		//计算tomato
		for (int m = 0;m < D;m++)
		{
			for (int n = 0;n < D;n++)
			{
				s[m][n] = abs(tomato[m] - nd[n]) + (1 + (exp(-0.1*(abs(day[m] - day[n]) - 105))));

				if (m == 0 && n == 0)
				{
					q[m][n] = s[0][0];
					continue;
				}
				if (m == 0 && n > 0)
				{
					q[m][n] = s[m][n] + q[0][n - 1];
					continue;
				}

				if (m > 0 && n == 0)
				{
					q[m][n] = s[m][n] + q[m - 1][0];
					continue;
				}
				else
				{
					q[m][n] = min(q[m - 1][n - 1], min(q[m][n - 1], q[m - 1][n])) + s[m][n];


					//q[m][n] = min(q[m - 1][n], q[m - 1][n - 1], q[m][n - 1]) + s[m][n];
				}

			}
		}
		C[i * K + 2] = q[D - 1][D - 1];


		//计算wheat
		for (int m = 0;m < D;m++)
		{
			for (int n = 0;n < D;n++)
			{
				s[m][n] = abs(wheat[m] - nd[n]) + (1 + (exp(-0.1*(abs(day[m] - day[n]) - 105))));

				if (m == 0 && n == 0)
				{
					q[m][n] = s[0][0];
					continue;
				}
				if (m == 0 && n > 0)
				{
					q[m][n] = s[m][n] + q[0][n - 1];
					continue;
				}

				if (m > 0 && n == 0)
				{
					q[m][n] = s[m][n] + q[m - 1][0];
					continue;
				}
				else
				{
					q[m][n] = min(q[m - 1][n - 1], min(q[m][n - 1], q[m - 1][n])) + s[m][n];

				}

			}
		}
		C[i * K + 3] = q[D - 1][D - 1];


	}




}

/********************************测试计算NDVI*************************/


void main(int argc, char **argv)
{
	//printf("\n%s STARTING...\n\n", argv[0]);

	clock_t tstart, tend;
	tstart = clock();												/////////////////////////////////////////////////////////////////////////////////////////s

	//读取数据
	array<const char*, D * 2> inputs = {
		"C:/Users/19144/Desktop/EX/IN/e1/B4.TIF",
		"C:/Users/19144/Desktop/EX/IN/e1/B5.TIF",
		"C:/Users/19144/Desktop/EX/IN/e2/B4.TIF",
		"C:/Users/19144/Desktop/EX/IN/e2/B5.TIF",
		"C:/Users/19144/Desktop/EX/IN/e3/B4.TIF",
		"C:/Users/19144/Desktop/EX/IN/e3/B5.TIF",
		"C:/Users/19144/Desktop/EX/IN/e4/B4.TIF",
		"C:/Users/19144/Desktop/EX/IN/e4/B5.TIF",
		"C:/Users/19144/Desktop/EX/IN/e5/B4.TIF",
		"C:/Users/19144/Desktop/EX/IN/e5/B5.TIF",
		"C:/Users/19144/Desktop/EX/IN/e6/B4.TIF",
		"C:/Users/19144/Desktop/EX/IN/e6/B5.TIF",

	};
	const char* outputs = "C:/Users/19144/Desktop/EX/IN/output/4x4_12PTWDTW8.TIF";

	array<GDALDataset*, D * 2> inputDatasets;
	GDALDataset* outputDataset;

	GDALAllRegister();

	cout << "正在读取影像中..." << endl;
	for (int i = 0; i < D * 2; i++)
	{
		inputDatasets[i] = (GDALDataset *)GDALOpen(inputs[i], GA_ReadOnly);
		if (inputDatasets[i] == NULL)
		{
			cout << "影像读取失败：（" << inputs[i] << "）！" << '\n';
			//return EXIT_FAILURE;
		}
	}


	int imgSizeX = inputDatasets[0]->GetRasterXSize(); // 影像的宽度（像元数目）
	int imgSizeY = inputDatasets[0]->GetRasterYSize(); // 影像的高度（像元数目）
	int imgSize = imgSizeX * imgSizeY;

	std::cout << "影像宽：" << imgSizeX << std::endl;
	std::cout << "影像高：" << imgSizeY << std::endl;

	const char* imageFormat = "GTiff";
	GDALDriver* gdalDriver = GetGDALDriverManager()->GetDriverByName(imageFormat);

	tend = clock();
	double time = (double)(tend - tstart) / CLOCKS_PER_SEC;							////////////////////////////////////////////////////////e
	cout << "共用时：" << time << "s" << endl;

	if (gdalDriver == NULL)
	{
		cout << "创建输出影像失败！！！" << '\n';
		//return EXIT_FAILURE;
	}

	outputDataset = gdalDriver->Create(outputs, X, Y, 1, GDT_Float32, NULL);

	// 获取输入数据的地理变化信息
	double goeInformation[6];
	inputDatasets[0]->GetGeoTransform(goeInformation);
	// 读取输入数据的地理信息并写入输出文件
	const char* gdalProjection = inputDatasets[0]->GetProjectionRef();
	outputDataset->SetGeoTransform(goeInformation);
	outputDataset->SetProjection(gdalProjection);

	cout << "正在进行数据处理..." << '\n';
	// 取得红波段和近红外波段
	// 读取数据，因为只有一个波段，所以Get第一波段的数据。

	GDALRasterBand* raseterBandRed = inputDatasets[0]->GetRasterBand(1);
	GDALRasterBand* raseterBandNIR = inputDatasets[1]->GetRasterBand(1);


	GDALRasterBand* raseterBandRed2 = inputDatasets[2]->GetRasterBand(1);
	GDALRasterBand* raseterBandNIR2 = inputDatasets[3]->GetRasterBand(1);


	GDALRasterBand* raseterBandRed3 = inputDatasets[4]->GetRasterBand(1);
	GDALRasterBand* raseterBandNIR3 = inputDatasets[5]->GetRasterBand(1);

	GDALRasterBand* raseterBandRed4 = inputDatasets[6]->GetRasterBand(1);
	GDALRasterBand* raseterBandNIR4 = inputDatasets[7]->GetRasterBand(1);

	GDALRasterBand* raseterBandRed5 = inputDatasets[8]->GetRasterBand(1);
	GDALRasterBand* raseterBandNIR5 = inputDatasets[9]->GetRasterBand(1);

	GDALRasterBand* raseterBandRed6 = inputDatasets[10]->GetRasterBand(1);
	GDALRasterBand* raseterBandNIR6 = inputDatasets[11]->GetRasterBand(1);

	GDALRasterBand* outputRasterBand = outputDataset->GetRasterBand(1);



	// 为读取影像申请内存

	float* bufferBlockRed = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockNIR = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockRed2 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockNIR2 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockRed3 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockNIR3 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockRed4 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockNIR4 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockRed5 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockNIR5 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockRed6 = (float*)CPLMalloc(sizeof(float) * X*Y);
	float* bufferBlockNIR6 = (float*)CPLMalloc(sizeof(float) * X*Y);

	int nxy = X * Y;
	size_t nBytes = nxy * sizeof(float);

	float* outputBufferBlock = (float*)CPLMalloc(sizeof(float) * X * Y);


	//*********进行NDVI时序曲线的计算***************

	raseterBandRed->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockRed, X, Y, GDT_UInt32, 0, 0);
	raseterBandNIR->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockNIR, X, Y, GDT_UInt32, 0, 0);
	raseterBandRed2->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockRed2, X, Y, GDT_UInt32, 0, 0);
	raseterBandNIR2->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockNIR2, X, Y, GDT_UInt32, 0, 0);
	raseterBandRed3->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockRed3, X, Y, GDT_UInt32, 0, 0);
	raseterBandNIR3->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockNIR3, X, Y, GDT_UInt32, 0, 0);
	raseterBandRed4->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockRed4, X, Y, GDT_UInt32, 0, 0);
	raseterBandNIR4->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockNIR4, X, Y, GDT_UInt32, 0, 0);
	raseterBandRed5->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockRed5, X, Y, GDT_UInt32, 0, 0);
	raseterBandNIR5->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockNIR5, X, Y, GDT_UInt32, 0, 0);
	raseterBandRed6->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockRed6, X, Y, GDT_UInt32, 0, 0);
	raseterBandNIR6->RasterIO(GF_Read, 0, 0, X, Y, bufferBlockNIR6, X, Y, GDT_UInt32, 0, 0);



	//set up device
	int dev = 0;
	cudaSetDevice(dev);
	cudaDeviceProp deviceprop;
	CHECK(cudaGetDeviceProperties(&deviceprop, dev));
	printf("using device %d:%s\n", dev, deviceprop.name);
	CHECK(cudaSetDevice(dev));

	getInfo(dev, deviceprop);
	// set up data size of vectors
	//int nElem = 1<<24;
	printf("Vector size %d\n", nxy);

	//分配主机内存

	float *h_Ar, *h_An, *h_Br, *h_Bn, *h_Cr, *h_Cn, *h_Dr, *h_Dn, *h_Er, *h_En, *h_Fr, *h_Fn,
		*hostRef, *output;
	h_Ar = bufferBlockRed;
	h_An = bufferBlockNIR;
	h_Bn = bufferBlockNIR2;
	h_Br = bufferBlockRed2;
	h_Cr = bufferBlockRed3;
	h_Cn = bufferBlockNIR3;
	h_Dn = bufferBlockNIR4;
	h_Dr = bufferBlockRed4;
	h_Er = bufferBlockRed5;
	h_En = bufferBlockNIR5;
	h_Fn = bufferBlockNIR6;
	h_Fr = bufferBlockRed6;


	hostRef = (float *)malloc(nBytes * K);
	output = outputBufferBlock;





	clock_t iStart, end;
	double  iElaps;

	//initialize data at host side
	iStart = clock();
	iElaps = clock() - iStart;

	memset(hostRef, 0, nBytes * K);
	memset(output, 0, nBytes);

	//分配设备内存 
	float *d_Ar, *d_An, *d_Br, *d_Bn, *d_Cr, *d_Cn, *d_Dr, *d_Dn, *d_Er, *d_En, *d_Fr, *d_Fn ,*d_D;
	cudaMalloc((float**)&d_Ar, nBytes);
	cudaMalloc((float**)&d_An, nBytes);
	cudaMalloc((float**)&d_Br, nBytes);
	cudaMalloc((float**)&d_Bn, nBytes);
	cudaMalloc((float**)&d_Cr, nBytes);
	cudaMalloc((float**)&d_Cn, nBytes);
	cudaMalloc((float**)&d_Dr, nBytes);
	cudaMalloc((float**)&d_Dn, nBytes);
	cudaMalloc((float**)&d_Er, nBytes);
	cudaMalloc((float**)&d_En, nBytes);
	cudaMalloc((float**)&d_Fr, nBytes);
	cudaMalloc((float**)&d_Fn, nBytes);
	cudaMalloc((float**)&d_D, nBytes * K);




	//拷贝数据至设备
	iStart = clock();
	cudaMemcpy(d_Ar, h_Ar, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_An, h_An, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Br, h_Br, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Bn, h_Bn, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Cr, h_Cr, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Cn, h_Cn, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Dr, h_Dr, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Dn, h_Dn, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Er, h_Er, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_En, h_En, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Fr, h_Fr, nBytes, cudaMemcpyHostToDevice);
	cudaMemcpy(d_Fn, h_Fn, nBytes, cudaMemcpyHostToDevice);
	end = clock();
	iElaps = (double)(end - iStart) / CLOCKS_PER_SEC;
	printf(" 拷贝数据耗时：%f sec\n", iElaps);





	CHECK(cudaMemcpy(d_Ar, h_Ar, nBytes, cudaMemcpyHostToDevice));

	//invoke kernel at host side
	int iLen = 128;
	dim3 block(iLen);
	//dim3 grid((imgSizeX + block.x - 1) / block.x);
	dim3 grid((X*Y + block.x - 1) / block.x);

	//////////////////////////////////////////////////////////////////iStart = clock();
	cout << "正在计算中..." << endl;
	ndviOnGPU << <grid, block >> > (d_Ar, d_An, d_Br, d_Bn, d_Cr, d_Cn, d_Dr, d_Dn, d_Er, d_En, d_Fr, d_Fn, d_D, nxy, X, Y);

	cudaError_t cudaStatus = cudaGetLastError();
	if (cudaStatus != cudaSuccess)
	{
		fprintf(stderr, "addKernel launch failed: %s\n", cudaGetErrorString(cudaStatus));
	}
	cudaDeviceSynchronize();


	//copy back to host
	cudaMemcpy(hostRef, d_D, nBytes * K, cudaMemcpyDeviceToHost);

	iStart = clock();
	int zero = 0;
	for (int i = 0;i < nxy;i++)
	{
		float min = hostRef[i * K];
		if (hostRef[i * K] == 0)
		{
			output[i] = 0;
			zero++;
		}
		else
		{
			output[i] = 1;
			if (hostRef[i * K + 1] < min)
			{
				output[i] = 2;
				min = hostRef[i * K + 1];
			}
			if (hostRef[i * K + 2] < min)
			{
				output[i] = 3;
				min = hostRef[i * K + 2];
			}
			if (hostRef[i * K + 3] < min)
			{
				output[i] = 4;
				min = hostRef[i * K + 3];
			}

		}




	}
	cout << "0的值有：" << zero << endl;
	//输出
	outputRasterBand->RasterIO(GF_Write, 0, 0, X, Y, outputBufferBlock, X, Y, GDT_Float32, 0, 0); // 写入数据



	//printf("Execution configuration<<<%d,%d>>>\n", grid.x, block.x);
	end = clock();
	iElaps = (double)(end - iStart) / CLOCKS_PER_SEC;
	printf("sumArrayOnGPU<<<%d,%d>>>Time elapsed %f s\n", grid.x, block.x, iElaps);

	int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0;
	//统计各像元个数
	for (int i = 0;i < nxy;i++)
	{

		if (outputBufferBlock[i] == 1)
		{
			a++;
		}
		if (outputBufferBlock[i] == 2)
		{
			b++;
		}
		if (outputBufferBlock[i] == 3)
		{
			c++;
		}
		if (outputBufferBlock[i] == 4)
		{
			d++;
		}


		if (i == nxy - 1) {
			cout << "第一类有：" << a << endl;
			cout << "第二类有：" << b << endl;
			cout << "第三类有：" << c << endl;
			cout << "第四类有：" << d << endl;
		}
		if (i == nxy - 1)
		{
			cout << a + b + c + d + e + f + g + h << endl;
		}

	}


	//测试是否计算完毕
	cout << h_Ar[X*Y - 1] << endl;
	cout << h_An[X*Y - 1] << endl;
	cout << h_Br[X*Y - 1] << endl;
	cout << h_Bn[X*Y - 1] << endl;
	cout << hostRef[X*Y * K - 1] << endl;

	//free device global memory
	cudaFree(d_Ar);
	cudaFree(d_An);
	cudaFree(d_Bn);
	cudaFree(d_Br);
	cudaFree(d_Cr);
	cudaFree(d_Cn);
	cudaFree(d_Dn);
	cudaFree(d_Dr);
	cudaFree(d_Er);
	cudaFree(d_En);
	cudaFree(d_Fn);
	cudaFree(d_Fr);
	cudaFree(d_D);



	// 释放资源
	CPLFree(bufferBlockRed);
	CPLFree(bufferBlockNIR);
	CPLFree(outputBufferBlock);
	CPLFree(bufferBlockRed2);
	CPLFree(bufferBlockNIR2);
	CPLFree(bufferBlockRed3);
	CPLFree(bufferBlockNIR3);
	CPLFree(bufferBlockRed4);
	CPLFree(bufferBlockNIR4);
	CPLFree(bufferBlockRed5);
	CPLFree(bufferBlockNIR5);
	CPLFree(bufferBlockRed6);
	CPLFree(bufferBlockNIR6);

	free(hostRef);

	GDALClose(inputDatasets[0]);
	GDALClose(inputDatasets[1]);
	GDALClose(inputDatasets[2]);
	GDALClose(inputDatasets[3]);
	GDALClose(inputDatasets[4]);
	GDALClose(inputDatasets[5]);
	GDALClose(inputDatasets[6]);
	GDALClose(inputDatasets[7]);
	GDALClose(inputDatasets[8]);
	GDALClose(inputDatasets[9]);
	GDALClose(inputDatasets[10]);
	GDALClose(inputDatasets[11]);

	GDALClose(outputDataset);

#pragma omp parallel
#pragma omp for
	for (int i = 0;i < 4;i++)
	{
		printf("tid=%d,i=%d\n", omp_get_thread_num(), i);
	}
	printf("threadsnums:%d\n", omp_get_num_threads());
	printf("cpu nums:%d\n", omp_get_num_procs());
	printf("time:%lf\n", time);

	//return 0;
	getchar(); // 防止控制台一闪而过
}

























